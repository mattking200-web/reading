// === Passages (make sure these are defined — copy from your original if needed) ===
const passages = [
  "The cat sat on the mat. The cat is fat. Fat cat, fat cat, sit on the mat. The dog can run. Run dog, run!",
  "Sam and Pam like to play. They play all day. Pam has a big red ball. Sam kicks the ball. Kick, kick, kick the red ball! They laugh and play.",
  "The little bird flew through the sky. It was a beautiful day. The bird sang a happy song. Tweet tweet! Enough rain had fallen. Now the sun shines bright again."
];

const practiceWords = [
  ["cat", "fat", "mat"],
  ["play", "ball", "kick"],
  ["through", "enough", "beautiful"]
];

// App state
let currentLevel = 0;
let consecutiveSuccess = 0;
let recognition = null;
let currentPassageText = "";
let currentPassageLower = "";
let passageWordSet = new Set();

const startBtn = document.getElementById('start');
const stopBtn = document.getElementById('stop');
const passageDiv = document.getElementById('passage');
const statusDiv = document.getElementById('status');
const transcribedDiv = document.getElementById('transcribed');
const accuracyDiv = document.getElementById('accuracy');
const levelSelect = document.getElementById('levelSelect');
const newPassageBtn = document.getElementById('newPassage');

const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

if (!SpeechRecognition) {
  statusDiv.innerHTML = '<span class="error">Sorry, your browser does not support Speech Recognition. Try the latest Google Chrome.</span>';
  startBtn.disabled = true;
} else {
  recognition = new SpeechRecognition();
  recognition.continuous = true;
  recognition.interimResults = false;  // Only final results — cleaner
  recognition.maxAlternatives = 3;     // Get top 3 guesses
  recognition.lang = 'en-US';

  // Grammar hint (deprecated/no effect in current Chrome, but harmless)
  if ('SpeechGrammarList' in window) {
    const grammarList = new window.SpeechGrammarList();
    const allWords = [...new Set(practiceWords.flat())].join(' | ');
    const grammarString = `#JSGF V1.0; grammar passageWords; public <word> = ${allWords} ;`;
    grammarList.addFromString(grammarString, 1.0);
    recognition.grammars = grammarList;
  }

  recognition.onresult = (event) => {
    const result = event.results[event.results.length - 1];
    if (result.isFinal) {
      const candidates = [];
      for (let i = 0; i < result.length; i++) {
        candidates.push(result[i].transcript.trim().toLowerCase());
      }
      const bestMatch = findBestCandidate(candidates, currentPassageLower);
      transcribedDiv.innerHTML = `<strong>Best guess:</strong> ${bestMatch}<br><small>(alternatives: ${candidates.slice(1).join(', ') || 'none'})</small>`;
      calculateAccuracy(bestMatch);
    }
  };

  recognition.onend = () => {
    stopBtn.disabled = true;
    startBtn.disabled = false;
    statusDiv.textContent = "Listening stopped. Ready for next try!";
  };

  recognition.onerror = (event) => {
    statusDiv.innerHTML = `<span class="error">Error: ${event.error} — try a quieter room, closer mic, or check mic permissions.</span>`;
    stopBtn.disabled = true;
    startBtn.disabled = false;
  };
}

function loadPassage() {
  currentPassageText = passages[currentLevel];
  currentPassageLower = currentPassageText.toLowerCase();
  passageWordSet = new Set(currentPassageLower.split(/\s+/).filter(w => w));

  let highlighted = currentPassageText;
  practiceWords[currentLevel].forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    highlighted = highlighted.replace(regex, `<span class="highlight">${word}</span>`);
  });

  passageDiv.innerHTML = highlighted;
  transcribedDiv.innerHTML = '';
  accuracyDiv.innerHTML = '';
  statusDiv.textContent = `Read this passage clearly and steadily. Focus on the highlighted words!`;
}

// Pick best candidate based on word overlap with passage
function findBestCandidate(candidates, passageLower) {
  let best = candidates[0] || '';
  let bestScore = 0;

  candidates.forEach(candidate => {
    const words = candidate.split(/\s+/).filter(w => w);
    const score = words.filter(w => passageWordSet.has(w)).length;
    if (score > bestScore) {
      bestScore = score;
      best = candidate;
    }
  });
  return best;
}

function calculateAccuracy(transcribedLower) {
  if (!currentPassageLower) return;

  const originalWords = currentPassageLower.split(/\s+/).filter(w => w);
  const spokenWords = transcribedLower.split(/\s+/).filter(w => w);

  let correct = 0;
  const spokenSet = new Set(spokenWords);
  originalWords.forEach(word => {
    if (spokenSet.has(word)) correct++;
  });

  const accuracy = originalWords.length > 0 ? Math.round((correct / originalWords.length) * 100) : 0;

  accuracyDiv.innerHTML = `Accuracy: <strong>${accuracy}%</strong>`;

  if (accuracy >= 90) {
    consecutiveSuccess++;
    statusDiv.innerHTML = `<span class="success">Great job! ${accuracy}% correct. Successes: ${consecutiveSuccess}/2</span>`;
    if (consecutiveSuccess >= 2 && currentLevel < passages.length - 1) {
      currentLevel++;
      consecutiveSuccess = 0;
      statusDiv.innerHTML += `<br><strong>→ Moving up to Level ${currentLevel + 1}!</strong>`;
      levelSelect.value = currentLevel;
      loadPassage();
    }
  } else {
    consecutiveSuccess = 0;
    statusDiv.innerHTML = `<span class="error">Good try! ${accuracy}% — let's practice more (especially tricky sounds like T vs K).</span>`;
  }
}

// Event listeners
startBtn.onclick = () => {
  if (!recognition) return;
  transcribedDiv.innerHTML = '';
  recognition.start();
  startBtn.disabled = true;
  stopBtn.disabled = false;
  statusDiv.textContent = "Listening... Speak clearly, a bit slower, and closer to the mic if possible!";
};

stopBtn.onclick = () => {
  recognition?.stop();
};

levelSelect.onchange = () => {
  currentLevel = parseInt(levelSelect.value);
  consecutiveSuccess = 0;
  loadPassage();
};

newPassageBtn.onclick = loadPassage;

// Initial load
loadPassage();
