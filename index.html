// === Passages (unchanged) ===
const passages = [ /* your existing array */ ];
const practiceWords = [ /* your existing array */ ];

// App state (add these)
let currentLevel = 0;
let consecutiveSuccess = 0;
let recognition = null;
let currentPassageText = "";
let currentPassageLower = "";
let passageWordSet = new Set(); // for quick lookup

const startBtn = document.getElementById('start');
const stopBtn = document.getElementById('stop');
const passageDiv = document.getElementById('passage');
const statusDiv = document.getElementById('status');
const transcribedDiv = document.getElementById('transcribed');
const accuracyDiv = document.getElementById('accuracy');
const levelSelect = document.getElementById('levelSelect');
const newPassageBtn = document.getElementById('newPassage');

const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
if (!SpeechRecognition) {
  statusDiv.innerHTML = '<span class="error">Sorry, your browser does not support Speech Recognition. Try the latest Google Chrome.</span>';
  startBtn.disabled = true;
} else {
  recognition = new SpeechRecognition();
  recognition.continuous = true;
  recognition.interimResults = false;          // Only final → less noise
  recognition.maxAlternatives = 3;             // Get top 3 guesses
  recognition.lang = 'en-US';

  // Optional: grammar hint (helps a bit on expected vocab)
  if ('SpeechGrammarList' in window) {
    const grammarList = new window.SpeechGrammarList();
    grammarList.addFromString(`#JSGF V1.0; grammar passageWords; public <word> = ${practiceWords.flat().join(' | ')} ;`);
    recognition.grammars = grammarList;
  }

  recognition.onresult = (event) => {
    const result = event.results[event.results.length - 1];
    if (result.isFinal) {
      const candidates = Array.from({length: result.length}, (_, i) => result[i].transcript.trim().toLowerCase());
      const bestMatch = findBestCandidate(candidates, currentPassageLower);
      transcribedDiv.innerHTML = `<strong>Best guess:</strong> ${bestMatch}<br><small>(alternatives: ${candidates.slice(1).join(', ')})</small>`;
      calculateAccuracy(bestMatch);
    }
  };

  recognition.onend = () => {
    stopBtn.disabled = true;
    startBtn.disabled = false;
    statusDiv.textContent = "Listening stopped.";
  };

  recognition.onerror = (event) => {
    statusDiv.innerHTML = `<span class="error">Error: ${event.error} — try quieter room or lower mic sensitivity.</span>`;
    stopBtn.disabled = true;
    startBtn.disabled = false;
  };
}

function loadPassage() {
  currentPassageText = passages[currentLevel];
  currentPassageLower = currentPassageText.toLowerCase();
  passageWordSet = new Set(currentPassageLower.split(/\s+/).filter(w => w));

  let highlighted = currentPassageText;
  practiceWords[currentLevel].forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    highlighted = highlighted.replace(regex, `<span class="highlight">${word}</span>`);
  });
  passageDiv.innerHTML = highlighted;
  transcribedDiv.innerHTML = '';
  accuracyDiv.innerHTML = '';
  statusDiv.textContent = `Read clearly and steadily. Speak closer to the mic if needed!`;
}

// Pick best of top alternatives by how many words match the passage
function findBestCandidate(candidates, passageLower) {
  let best = candidates[0];
  let bestScore = 0;

  candidates.forEach(candidate => {
    const words = candidate.split(/\s+/);
    let score = words.filter(w => passageWordSet.has(w)).length;
    if (score > bestScore) {
      bestScore = score;
      best = candidate;
    }
  });
  return best;
}

// Improved accuracy: % of passage words found in spoken (with some forgiveness)
function calculateAccuracy(transcribedLower) {
  if (!currentPassageLower) return;

  const originalWords = currentPassageLower.split(/\s+/).filter(w => w);
  const spokenWords = transcribedLower.split(/\s+/).filter(w => w);

  let correct = 0;
  const spokenSet = new Set(spokenWords);
  originalWords.forEach(word => {
    if (spokenSet.has(word)) correct++;
  });

  const accuracy = originalWords.length > 0 ? Math.round((correct / originalWords.length) * 100) : 0;

  accuracyDiv.innerHTML = `Accuracy: <strong>${accuracy}%</strong>`;

  if (accuracy >= 90) {
    consecutiveSuccess++;
    statusDiv.innerHTML = `<span class="success">Great! ${accuracy}% — successes: ${consecutiveSuccess}/2</span>`;
    if (consecutiveSuccess >= 2 && currentLevel < passages.length - 1) {
      currentLevel++;
      consecutiveSuccess = 0;
      statusDiv.innerHTML += `<br><strong>→ Level up to ${currentLevel + 1}!</strong>`;
      levelSelect.value = currentLevel;
      loadPassage();
    }
  } else {
    consecutiveSuccess = 0;
    statusDiv.innerHTML = `<span class="error">Try again! ${accuracy}% — practice those tricky sounds.</span>`;
  }
}

// Button handlers (unchanged except start)
startBtn.onclick = () => {
  if (!recognition) return;
  transcribedDiv.innerHTML = '';
  recognition.start();
  startBtn.disabled = true;
  stopBtn.disabled = false;
  statusDiv.textContent = "Listening... Read clearly and a bit slower if needed!";
};

stopBtn.onclick = () => recognition?.stop();

levelSelect.onchange = () => {
  currentLevel = parseInt(levelSelect.value);
  consecutiveSuccess = 0;
  loadPassage();
};

newPassageBtn.onclick = loadPassage;

loadPassage();
